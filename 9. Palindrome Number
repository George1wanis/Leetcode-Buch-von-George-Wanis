https://leetcode.com/problems/palindrome-number/description/

ðŸ”¶ One of the comments said: "A small hint for negative numbers: return false." So I did this, next, i beleieve i should be able to know the length of the integer, like how many digits I do have.
ðŸ”¶ Another comment said: "Reversing the number and checking whether it equals the un-reversed version is a test of your coding ability, and might appear in a basic coding interview.
The 'don't convert to a string" variation will NEVER appear in an interview and is a bad question. Here's why:
You solved the problem by stringifying it. Why overthink things and use complicated and hard-to-debug math?
The "algorithmic" component of this is NOT part of a broader problem-solving paradigm in comptuer science (think of dynamic programming, graph algorithms, etc). Rather,
it's a one-off math trick."
ðŸ”¶Another said: If a number is a palindrome, its reverse equals itself. Which means its reverse is NOT overflow!!!
So that ' reversed integer might overflow' doesn't matter at all, since a overlowed number isn't a palindrome.
Now the question becomes whether a NONE palindrome == its reverse if we do NOT deal with overflow.
ðŸ”¶Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.
If you are talking about constant space, then even declaring a string/stack will take constant space.
(In fact, at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space.

ØºÙ„Ø¨ Ø­Ù…Ø§Ø±ÙŠ
https://www.youtube.com/watch?v=yubRKwixN-U

121%10 = 1
121/100 = 1
121/10 = 12
121%100 = 21
21/10 = 2
So think of it like this: you're a cook, and you wanna chop the unwanted pieces off.

class Solution {
public:
    bool isPalindrome(int x) {
        if (x < 0) return false; // this must be written first before the next line
        long long div = 1;
        while(x >= 10 * div) div*= 10; // the div should be multiplied by 10 not incremented
        while(x){
            if(x%10 != x/div) return false;
            x = (x%div)/10; // do not switch the div with the 10 
            div /= 100;
        }
        return true;
    }
};

âš¡ Alternative (cleaner & safer)
The reverse-half method avoids div entirely and overflow risks â€” tell me if you want that version too.
Nice attempt though â€” this is exactly the right direction for an O(1) space solution ðŸ‘Œ

âš¡ Best practice (LeetCode favorite)
Avoid div entirely â†’ reverse half the number
No overflow, cleaner, faster.

bool isPalindrome(int x) {
    if (x < 0 || (x % 10 == 0 && x != 0)) return false;
    int rev = 0;
    while (x > rev) {
        rev = rev * 10 + x % 10;
        x /= 10;
    }
    return (x == rev || x == rev / 10);
}
